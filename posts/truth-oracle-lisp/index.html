<!doctype html>
<html lang="en-US">
    <head>
        <meta charset="utf-8">
        <title>Writing a truth oracle in Lisp | Lambda Cove</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="alternate" type="application/atom+xml" title="RSS" href="https://lambda-cove.net/atom.xml">
        <link rel="stylesheet" href="/styles/normalize.css" />
        <link rel="stylesheet" href="/index.css" />

        <!-- KaTeX -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css" integrity="sha384-5TcZemv2l/9On385z///+d7MSYlvIEw9FuZTIdZ14vJLqWphw7e7ZPuOiCHJcFCP" crossorigin="anonymous">
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js" integrity="sha384-cMkvdD8LoxVzGF/RPUKAcvmm49FQ0oxwDF3BGKtDXcEc+T1b2N+teh/OJfpU0jr6" crossorigin="anonymous"></script>
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"
                onload="renderMathInElement(document.body);"></script>
    </head>
    <body>
        <header>
            <nav>
                <ul class="menu">
                    <li>
                        <a href="https://lambda-cove.net">Home</a>
                    </li>
                    <li>
                        <a href="https://lambda-cove.net/atom.xml">Atom Feed</a>
                    </li>
                </ul>
            </nav>
        </header>
        <div id="center-content">
            
<h1>Writing a truth oracle in Lisp</h1>
<div class="meta">
  <div class="post-date">
    <i>
      <time datetime='June 08, 2025' pubdate>June 08, 2025</time>
    </i>
  </div>
</div>
<main>
  <div class="note">
<p>This post assumes some familiarity with typed functional programming, Lisp, and formal logic.</p>
</div>
<p class="first-paragraph" data-first-letter="T">
Today we will attempt to write a truth oracle in Lisp.
By "truth oracle," I mean a program that can determine whether arbitrary mathematical statements are true or false.
This might sound impossible, due to first-order logic being undecidable,
but let's try anyway.
</p>
<p>Before that, though, we need to go over some required concepts.</p>
<h2 id="extracting-information-from-proofs">Extracting information from proofs</h2>
<p>First, sometimes, we can extract information from proofs themselves, beyond just the facts that they prove.</p>
<p>Imagine you want to prove a statement of the form “\(A\) or \(B\).”
If you can prove either \(A\) or \(B\), then you can prove “\(A\) or \(B\)” by the <a href="https://en.wikipedia.org/wiki/Disjunction_introduction">or-introduction</a> rule.
Let’s say you have a proof of this form,
and you want to figure out <em>which</em> of \(A\) or \(B\) is the one that’s true.
This is pretty easy.
You can just look at the last step of the proof,
and see if it’s <em>left-or-introduction</em> or <em>right-or-introduction</em>.
For example, if you have a proof that a number is either divisible by three or by five, you can look at the last step of the proof to see which it’s divisible by.</p>
<p>The same principle applies for proofs of existence.
If you want to prove “there exists \(x\) such that \(P(x)\),”
you can use the <a href="https://en.wikipedia.org/wiki/Existential_generalization">existential introduction</a> rule.
In other words, you can give the specific value \(x\) satisfying \(P(x)\), and then prove \(P(x)\) with that value.
Then if you have a proof of this form that there exists a number \(x\) such that there is a string of digits “123456789” starting at the \(x\)th digit of \(\pi\),
you can look at the existential introduction rule of the proof to see <em>where</em> in \(\pi\) you can find the digit string “123456789.”</p>
<p>In other words, for proofs of “or” statements, we can look at the proof to see which individual statement is true, and for proofs of existence we can look at the proof to see the value that exists.</p>
<h2 id="the-curry-howard-correspondence">The Curry-Howard correspondence</h2>
<p>The next concept is a relationship between proofs and programs called the
<a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence">Curry-Howard correspondence</a>.
This topic has a <em>lot</em> of depth and I’m not going to go into the full details, but the basics aren’t too complicated.
The core idea is that formal logic <em>proofs</em> can be thought of as <em>expressions</em> in a typed functional programming language, and vice versa.
Similarly, the <em>types</em> of expressions can be thought of as <em>propositions</em>, or statements, that the expressions prove.
I’ll describe some examples below.</p>
<h3 id="implication">Implication</h3>
<p>Consider the statement “\(A\) implies \(B\).”
If you have a proof that “\(A\) implies \(B\),” and a proof of \(A\),
you can combine them with <a href="https://en.wikipedia.org/wiki/Modus_ponens">implication elimination</a> to get a proof of \(B\).
In the Curry-Howard correspondence, implication corresponds to function types,
and implication elimination corresponds to function application.
If you have an expression \(f\) of type \(A \to B\) and an expression \(x\) of type \(A\),
you can combine them with function application to get an expression \(f(x)\) of type \(B\).
Incidentally, the right arrow “\(\to\)” symbol is commonly used for both implication and function types.</p>
<h3 id="and">And</h3>
<p>You can prove “\(A\) and \(B\)” using <a href="https://en.wikipedia.org/wiki/Conjunction_introduction">and-introduction</a> if you can prove \(A\) and you can prove \(B\).
You can also use <a href="https://en.wikipedia.org/wiki/Conjunction_elimination">and-elimination</a> with a proof of “\(A\) and \(B\)” to get back a proof of \(A\) and a proof of \(B\).
In functional programming, this corresponds to tuples.
Given an expression \(x\) of type \(A\) and \(y\) of type \(B\),
you can construct a tuple \((x,y)\) of type \((A,B)\).
And you can also destruct a tuple of type \((A,B)\) to get back \(x\) and \(y\).</p>
<h3 id="or">Or</h3>
<p>With <a href="https://en.wikipedia.org/wiki/Disjunction_introduction">or-introduction</a>, you can prove “\(A\) or \(B\)” from a proof of \(A\) or a proof of \(B\).
In programming languages, this corresponds to <a href="https://en.wikipedia.org/wiki/Tagged_union">sum types</a> (types that can be one of several variants), sometimes called “either types,” variants, discriminated unions, or coproducts.
In Rust, these are called <code>enum</code>, or <code>Result&lt;T, E&gt;</code> for the specific case where one of the types is for normal output and the other is for errors.
In Haskell, there is a type <code>Either A B</code> with constructors <code>Left a</code> and <code>Right b</code>.
In Rust, if you have an expression <code>val</code> of type <code>T</code> or an expression <code>err</code> of type <code>E</code>,
you can construct an expression <code>Ok(val)</code> or <code>Err(err)</code> of type <code>Result&lt;T, E&gt;</code>.
In Haskell, if you have <code>a : A</code> or <code>b : B</code>, then you can construct <code>Either A B</code> with <code>Left a</code> or <code>Right b</code>.</p>
<p>The opposite direction, <a href="https://en.wikipedia.org/wiki/Disjunction_elimination">or-elimination</a>, is a little more complicated.
Given a proof of “\(A\) or \(B\),” if you prove that both \(A\) and \(B\) imply the same conclusion \(C\), then you can use or-elimination to prove \(C\).
This corresponds to pattern matching in programming languages.</p>
<p>In Haskell, if you have a value <code>x</code> of type <code>Either a b</code>
and you have functions mapping both <code>a</code> and <code>b</code> to a shared type <code>c</code>,
you can use pattern matching to get a value of type <code>c</code>.</p>
<pre data-lang="haskell" class="language-haskell "><code class="language-haskell" data-lang="haskell">patternMatch :: Either a b -&gt; (a -&gt; c) -&gt; (b -&gt; c) -&gt; c
patternMatch x f g =
  case x of
    Left v -&gt; f v
    Right v -&gt; g v
</code></pre>
<p>And in Rust, if you have a value <code>x</code> of type <code>Result&lt;A, B&gt;</code>
and you have functions mapping both <code>A</code> and <code>B</code> to a shared type <code>C</code>,
you can use pattern matching to get a value of type <code>C</code>.</p>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">fn pattern_match&lt;A, B, C&gt;(
    x: Result&lt;A, B&gt;,
    f: fn(A) -&gt; C,
    g: fn(B) -&gt; C
) -&gt; C {
    match x {
        Ok(v) =&gt; f(v),
        Err(v) =&gt; g(v),
    }
}
</code></pre>
<h3 id="contradiction">Contradiction</h3>
<p>A contradiction “\(\bot\)” is a proposition that has no proofs (i.e. it’s unprovable, and false).
Propositions correspond to types,
and proofs correspond to values.
So a contradiction corresponds to an <a href="https://en.wikipedia.org/wiki/Empty_type">empty type</a>,
a type with no values.
In programming languages with sum types, this can be represented with a sum type with no variants, such as <a href="https://docs.rs/void/1.0.2/void/enum.Void.html"><code>enum Void {}</code></a> in Rust.
However, Rust also includes a <a href="https://doc.rust-lang.org/std/primitive.never.html">primitive “never” type <code>!</code></a> which serves this purpose.
These types are typically used for expressions that don’t return normally,
such as infinite loops, thrown exceptions,
or fatal errors.</p>
<p>In formal logic,
if you have a proof of a contradiction,
you can use it to prove anything,
by the <a href="https://en.wikipedia.org/wiki/Principle_of_explosion">principle of explosion</a>.
Similarly,
in functional programming,
an expression of the empty type can be used to get an expression of any type.
If the empty type is represented as a sum type with zero variants, you can pattern match on the expression to get an expression of any arbitrary type.
In the case of Rust’s “never” type, it is coerced automatically to other types.</p>
<h3 id="negation">Negation</h3>
<p>Logical negation “\(\lnot A\)” (“not \(A\)”) is equivalent to implying a contradiction “\(A \to \bot\)” (“\(A\) implies a contradiction”).
We can say this because
the core property we want for logical negation is that
if we know both a statement and its negation,
we can derive a contradiction.
For example,
if we know “\(A\)” and “\(A\) implies a contradiction” we can use
<a href="https://en.wikipedia.org/wiki/Modus_ponens">implication elimination</a>
to derive a contradiction.
We’ve already shown that implication corresponds to function types, and contradictions correspond to empty types,
so we now know that logical negation is isomorphic with function types where the return type is an empty type.</p>
<h3 id="summary">Summary</h3>
<p>Here’s a table summarizing the correspondence, adapted from the one on <a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence">Wikipedia</a>.</p>
<table><thead><tr><th>Logic</th><th>Typed functional programming</th></tr></thead><tbody>
<tr><td>Statement</td><td>Type</td></tr>
<tr><td>Proof</td><td>Expression/Value/Program</td></tr>
<tr><td>Statement is true</td><td>Type has some possible values</td></tr>
<tr><td>Statement is false</td><td>Type has no possible values</td></tr>
<tr><td>Implication</td><td>Function type</td></tr>
<tr><td>And (conjunction)</td><td>Tuple</td></tr>
<tr><td>Or (disjunction)</td><td>Sum type</td></tr>
<tr><td>\(\bot\)</td><td>Empty type</td></tr>
<tr><td>not \(A\)</td><td>Type of function that takes \(A\) and returns the empty type</td></tr>
</tbody></table>
<h2 id="truth-oracle-in-lisp">Truth oracle in Lisp</h2>
<p>Now that we understand how proofs in formal logic correspond to programs,
we can use this knowledge to build a function that tells us whether any logical statement is true.</p>
<p>Now, we know there’s a correspondence between proofs and programs, and that we can extract information from proofs, such as whether \(A\) or \(B\) is true from a proof of “\(A\) or \(B\).” As it turns out, typed Racket (a Lisp with static typing) has a function <code>call/cc</code> that is Curry-Howard-isomorphic with <a href="https://en.wikipedia.org/wiki/Peirce%27s_law">Peirce’s law</a>.
This is an axiom of logic that says that “\(((A \to B) \to A) \to A\).”
It happens to be equivalent to <a href="https://en.wikipedia.org/wiki/Law_of_excluded_middle">the law of excluded middle</a>,
which says that every statement is either true or false (\(A\) or not \(A\)).
Since you can use Peirce’s law to prove the law of excluded middle,
we should be able to use <code>call/cc</code> to implement a program that is Curry-Howard-isomorphic to the law of excluded middle.
Let’s try that.</p>
<p>First, we’ll use <a href="https://rocq-prover.org/">Rocq Prover</a> to prove that Peirce’s law implies excluded middle.
Rocq Prover is a tool for writing formal proofs that uses a typed functional language called <a href="https://rocq-prover.org/doc/V8.9.1/refman/language/gallina-specification-language.html">Gallina</a> as its proof format.
By the Curry-Howard correspondence, this is a valid way to represent proofs.
Don’t worry if you aren’t familiar with the specifics of Rocq and its syntax;
the key insight is just that we are proving Peirce’s law implies the law of excluded middle.
The proof looks like this:</p>
<pre data-lang="rocq" class="language-rocq "><code class="language-rocq" data-lang="rocq">Theorem peirce_implies_em :
  (forall A B, ((A -&gt; B) -&gt; A) -&gt; A)
  -&gt; (forall A, A \&#x2F; ~A).
Proof.
  intros peirce A.
  apply peirce with (B := False).
  auto.
Qed.
</code></pre>
<p>This proof is not written in the Gallina functional programming language, but a higher-level tactic language for manipulating the underlying Gallina expressions.
Thankfully, Rocq lets us print out the generated Gallina program.
Let’s do that, so we can translate it to typed Racket.</p>
<pre data-lang="rocq" class="language-rocq "><code class="language-rocq" data-lang="rocq">Print peirce_implies_em.
</code></pre>
<pre data-lang="rocq" class="language-rocq "><code class="language-rocq" data-lang="rocq">peirce_implies_em =
fun (peirce : forall A B : Type, ((A -&gt; B) -&gt; A) -&gt; A)
    (A : Prop)
    =&gt; peirce
         (A \&#x2F; ~ A)
         False
         (fun (not_em : A \&#x2F; ~ A -&gt; False)
              =&gt; or_intror
                 ((fun a : A =&gt; not_em (or_introl a)) : ~ A)
         )
</code></pre>
<p>Notice that the proof is that Peirce’s law implies excluded middle,
and the program is a function that takes as an argument a proof of Peirce’s law and returns a proof of the excluded middle.
Let’s translate the body of the function to typed Racket,
replacing <code>peirce</code> with <code>call/cc</code>.</p>
<pre data-lang="racket" class="language-racket "><code class="language-racket" data-lang="racket">#lang typed&#x2F;racket

(struct (L) Left ([v : L]))
(struct (R) Right ([v : R]))
(define-type (Either L R)
  (U (Left L) (Right R)))

(define-type (Not A) (-&gt; A Nothing))
(define-type (EM A) (Either A (Not A)))

(: peirce (All (A B) (-&gt; (-&gt; (-&gt; A B) A) A)))
(define (peirce ABA) : A
  (call&#x2F;cc ABA))

(: em-raw (All (A) (-&gt; (-&gt; A A) (EM A))))
(define (em-raw a_implies_a)
  (peirce (lambda ([not_em : (Not (EM A))]) : (EM A)
            (Right (lambda ([a : A])
                     (not_em (Left a)))))))

(define-syntax-rule (em A)
  (em-raw (lambda ([a : A]) : A a)))
</code></pre>
<p>Here <a href="https://docs.racket-lang.org/ts-reference/type-ref.html#%28form._%28%28lib._typed-racket%2Fbase-env%2Fbase-types..rkt%29._.Nothing%29%29"><code>Nothing</code></a> is the empty type corresponding to a contradiction,
<code>(Either L R)</code> is a sum type corresponding to logical “or,”
and <code>(-&gt; A B)</code> is a function type corresponding to logical implication. Due to what looks like a type inference limitation,
we need our excluded middle function to take an identity function as a parameter,
so we define a macro that takes a type as a parameter
and creates the necessary identity function and passes it to the <code>em-raw</code> function to get a proof that <code>A</code> is either true or false.</p>
<p>But wait, didn’t we show at the beginning that if we have a proof of “\(A\) or \(B\),” we can look at the last step of the proof to see which one of \(A\) and \(B\) is true? In this case \(B\) is just “not \(A\).” We have a function where we can input any statement, and it evaluates to an expression corresponding to a proof that the statement is either true or false. If we print this expression, we can see whether it looks like <code>(Left ...)</code> or <code>(Right ...)</code> to see whether \(A\) is true or false.</p>
<p>We have created our truth oracle in typed Racket.
We have a function that tells us whether any logical statement is true.
If this works, what can we do with this?</p>
<p>We can instantly mine every new Bitcoin,
worth (as of writing this) 48 million dollars per day,
by encoding the statement,
“there exists a <a href="https://www.investopedia.com/terms/n/nonce.asp">nonce</a> starting with a prefix <em>p</em> that makes this block’s hash below the target value,”
in formal logic,
and gradually expanding the prefix while the oracle says the statement is true.
Eventually, the prefix will be the full nonce and you will have mined the block.
Since the nonce is 32-bits, you would only need to call the oracle 32 times,
once for each bit, to figure out if it should be 0 or 1.</p>
<p>We can solve all open problems in mathematics and formally verify our solutions,
by using a similar technique to generate formal proofs.</p>
<p>We can encode all known laws of physics and ask for
solutions to engineering problems.</p>
<p>We can figure out whether any arbitrary Turing machine will halt.</p>
<p>We can compute the <a href="https://en.wikipedia.org/wiki/Kolmogorov_complexity">Kolmogorov complexity</a> of all available stock market data, combined with possible future data,
to possibly perfectly predict stock price movements, but this is more speculative.</p>
<p>We can replace the inefficient gradient descent local optimization of machine learning with a process that <em>globally</em> chooses the best possible weights, and does so much more quickly, which would let any consumer-grade computer train AI systems much more powerful than leading AI labs.</p>
<p>We can implement <a href="https://en.wikipedia.org/wiki/AIXI">AIXI</a>, an algorithm for artificial general intelligence, implemented as an optimal reinforcement learning agent.</p>
<p>With all these possibilities, let’s try using it.</p>
<p>First we’ll try something simple, that “false” is false.</p>
<pre data-lang="racket" class="language-racket "><code class="language-racket" data-lang="racket">(em Nothing)
</code></pre>
<pre data-lang="racket" class="language-racket "><code class="language-racket" data-lang="racket">#&lt;Right&gt;
</code></pre>
<p>Here <code>Nothing</code> corresponds to a contradiction,
and our oracle correctly says it’s false!</p>
<p>Now we’ll check “for all statements A, A is true.”</p>
<pre data-lang="racket" class="language-racket "><code class="language-racket" data-lang="racket">(em (All (A) A))
</code></pre>
<pre data-lang="racket" class="language-racket "><code class="language-racket" data-lang="racket">#&lt;Right&gt;
</code></pre>
<p>Some things aren’t true, so it correctly says it’s false!</p>
<p>Next we’ll try something more complicated.
Let’s see if our oracle thinks 3 is even.</p>
<pre data-lang="racket" class="language-racket "><code class="language-racket" data-lang="racket">(em (Refine [x : Natural] (= (* 2 x) 3)))
</code></pre>
<pre data-lang="racket" class="language-racket "><code class="language-racket" data-lang="racket">#&lt;Right&gt;
</code></pre>
<p>This statement means “there exists natural number \(x\) such that \(2x = 3\),”
which is equivalent to saying 3 is even,
and it correctly says it’s false again!</p>
<p>Now let’s try checking if 10 is even.</p>
<pre data-lang="racket" class="language-racket "><code class="language-racket" data-lang="racket">(em (Refine [x : Natural] (= (* 2 x) 10)))
</code></pre>
<pre data-lang="racket" class="language-racket "><code class="language-racket" data-lang="racket">#&lt;Right&gt;
</code></pre>
<p>Oh, this is true but our oracle is saying it’s false.
Come to think of it, our oracle has only ever said statements are false.</p>
<p>Let’s try something simpler.
Does it think any natural number exists?
Since a type having a value corresponds to a statement having a proof,
the type of natural numbers corresponds to the statement that at least one natural number exists.</p>
<pre data-lang="racket" class="language-racket "><code class="language-racket" data-lang="racket">(em Natural)
</code></pre>
<pre data-lang="racket" class="language-racket "><code class="language-racket" data-lang="racket">#&lt;Right&gt;
</code></pre>
<p>Okay, it looks like our oracle is just saying everything is false.
Maybe there’s a bug, or maybe one of our assumptions is wrong?</p>
<p>Wait, …but there <em>can’t</em> be a bug, because the type signature of <code>em</code> ensures the behavior we want.
It could be a bug in typed Racket’s type checker, potentially.
Let’s try to combine the proof of a false statement that it gives us with a proof of its negation, to get a contradiction.
Recall that this is Curry-Howard isomorphic with a type that has no possible values.
If we print out the impossible value that has this type,
we can try to get some idea what’s going on here.</p>
<p>First, we’ll set up a way to get the inner proof that no number exists.</p>
<pre data-lang="racket" class="language-racket "><code class="language-racket" data-lang="racket">(let ([proof : (Either Natural (Not Natural))
       (em Natural)])
  (if (Left? proof)
    (format &quot;A number exists: ~a&quot;
            (Left-v proof))
    (format &quot;No number exists: ~a&quot;
            (Right-v proof))))
</code></pre>
<pre data-lang="racket" class="language-racket "><code class="language-racket" data-lang="racket">&quot;No number exists: #&lt;procedure&gt;&quot;
</code></pre>
<p>The proof that no number exists is a <code>#&lt;procedure&gt;</code> value of type <code>(Not Natural)</code>.
Recall from the definition of <code>Not</code> that this is equivalent to
<code>(-&gt; Natural Nothing)</code>,
so this procedure value corresponds to a proof that a natural number implies a contradiction.
We can pass the function a natural number,
and it will return a value that can’t exist.
This shouldn’t be possible, but let’s see what happens!
We’ll just replace <code>(Right-v proof)</code> with <code>((Right-v proof) 283)</code>.</p>
<pre data-lang="racket" class="language-racket "><code class="language-racket" data-lang="racket">(let ([proof : (Either Natural (Not Natural))
       (em Natural)])
  (if (Left? proof)
    (format &quot;A number exists: ~a&quot;
            (Left-v proof))
    (format &quot;Value that shouldn&#x27;t exist: ~a&quot;
            ((Right-v proof) 283))))
</code></pre>
<pre data-lang="racket" class="language-racket "><code class="language-racket" data-lang="racket">&quot;A number exists: 283&quot;
</code></pre>
<p>Huh, when we modify the code to create the impossible value,
the oracle now correctly says the statement is true.
But the oracle runs <strong><em>before</em></strong> the impossible value is created.
And the number it gives us to prove a number exists is the <em>same number</em>
we use to create the impossible value in the branch that <em>doesn’t even run</em>???
Not only is code that runs later in the program influencing code that runs earlier, the code that runs later doesn’t run at all, and it also somehow passes a value back in time?
The code somehow knows what number we’ll use in the future,
in code that never even runs, and changes its answer accordingly.
What!!?!</p>
<hr />
<p>Okay, it turns out that we didn’t really write a truth oracle,
and <code>call/cc</code> isn’t a normal function.
To understand what’s going on,
we need to go over some more concepts.</p>
<h2 id="constructive-vs-classical-logic">Constructive vs classical logic</h2>
<p>One detail I glossed over earlier was the distinction between constructive and classical logic.
This is critical to understanding this bizarre behavior.
The “extracting information from proofs” section was a bit misleading.
Specifically, it stops being true once you add certain axioms.
I said that if you have a proof of “\(A\) or \(B\),”
you can look at the last step of the proof to see if
it’s the left-or-introduction or right-or-introduction rule,
to see which of \(A\) or \(B\) is the one that’s true.
But one important detail I left out is this requires that left-or-introduction and right-or-introduction are the only rules to create proofs of logical “or” statements.
There is another rule for proving “or” statements that is commonly added as an axiom, namely, the <em><a href="https://en.wikipedia.org/wiki/Law_of_excluded_middle">law of excluded middle</a></em>, the <em>same rule that we implemented in typed Racket</em>.</p>
<p>Logic without the law of excluded middle, or anything equivalent to it, is called <em><a href="https://en.wikipedia.org/wiki/Intuitionistic_logic">constructive logic</a></em>.
It is called “constructive,” because in order to prove “\(A\) or \(B\),”
you need to decide whether \(A\) or \(B\) is true and directly construct a proof of that.
Similarly, in order to prove that a value exists that has some property,
you need to give the actual value that exists.
This makes it map nicely to functional programming in the Curry-Howard isomorphism.
Normally to get a value of a sum type, you have to know the specific variant in order to construct it.
For example, to construct a <code>Result&lt;T, E&gt;</code> in Rust,
you need to specifically use <code>Ok()</code> or <code>Err()</code>.</p>
<p>When you add the law of excluded middle, or something equivalent to it,
constructive logic becomes <em><a href="https://en.wikipedia.org/wiki/Classical_logic">classical logic</a></em>.
It lets you prove “or” statements without you needing to know which statement is true,
and it lets you prove existence of an object without needing to actually know the object.
Here is an example classical proof to give you an idea of what this is like:</p>
<p>Let’s say we want to prove that there exists irrational numbers \(x\) and \(y\) such that \(x^y\) is rational.
We know that \(\sqrt 2\) is irrational.
By the law of excluded middle,
we know that \(\left(\sqrt 2 \right) ^ {\sqrt 2}\) is either rational or irrational.
We can consider the consequences of each case separately:</p>
<ol>
<li>
<p>If it’s rational, then we can say the values of \(x\) and \(y\) are
both \(\sqrt 2\).
Then \(x\) and \(y\) are both irrational and \(x^y\) is rational. This is what we wanted to show, so that means the proof is valid for this case.</p>
</li>
<li>
<p>If \(\left(\sqrt 2 \right) ^ {\sqrt 2}\) is irrational,
then we can say the values of \(x\) and \(y\) are
\(x = \left(\sqrt 2 \right) ^ {\sqrt 2}\) and \(y = \sqrt{2}\).
Then, \(x\) and \(y\) are both irrational and</p>
<p>\(x^y\)
\(= \left( \left(\sqrt{2}\right)^{\sqrt{2}} \right)^{\sqrt{2}}\)
\(= \left(\sqrt{2}\right)^{\sqrt{2} \times \sqrt{2}}\)
\(= \left(\sqrt{2}\right)^2\)
\(= 2\),</p>
<p>which is rational,
and that finishes the proof.</p>
</li>
</ol>
<p>(Source: <a href="https://softwarefoundations.cis.upenn.edu/lf-current/Logic.html">Software Foundations</a>)</p>
<p>Note that even though we proved that values \(x\) and \(y\) exist,
we didn’t need to prove what they are.
We gave two possibilities, but from the proof alone,
we don’t know which possibility is correct.
This is because of the use of the law of excluded middle in the beginning.
That makes it a <em>non-constructive</em> proof, which lets us prove values exist without knowing what they are.</p>
<h2 id="the-call-cc-function">The <code>call/cc</code> function</h2>
<p>Constructive logic corresponds nicely to functional programming under the Curry-Howard correspondence.
But Racket’s <code>call/cc</code> function corresponds to
<a href="https://en.wikipedia.org/wiki/Peirce%27s_law">Peirce’s law</a>,
which is equivalent to the law of excluded middle,
and thus part of classical logic and not constructive logic.
How does this work?
Well, <a href="https://en.wikipedia.org/wiki/Call-with-current-continuation"><code>call/cc</code></a> is not a normal function.
It has different control-flow than normally expected in functional programming languages,
which caused the strange behavior in our program.</p>
<p>The full name of <code>call/cc</code> is <a href="https://en.wikipedia.org/wiki/Call-with-current-continuation">call-with-current-continuation</a>.
It takes a function as its argument,
and it calls the function,
passing it something called the “current continuation.”
For example, <code>(call/cc (lambda (cc) "foo"))</code> evaluates to <code>"foo"</code>.
But what does the “current continuation” do?</p>
<p>It’s a function that takes as input a value,
and rolls the program state <em>back in time</em>,
making the <code>call/cc</code> expression return that value instead.</p>
<p>Let’s look at an example to understand this better:</p>
<pre data-lang="racket" class="language-racket "><code class="language-racket" data-lang="racket">#lang racket

(define (main)
  (define continuation null)
  (define value
    (string-append
     &quot;prefix | &quot;
     (call&#x2F;cc (lambda (cc)
                (set! continuation cc)
                &quot;original value&quot;))))
  (println value)
  (continuation &quot;new value&quot;))

(main)
</code></pre>
<pre data-lang="racket" class="language-racket "><code class="language-racket" data-lang="racket">&quot;prefix | original value&quot;
&quot;prefix | new value&quot;
...
</code></pre>
<p>In this example program,
we save the continuation in a variable called <code>continuation</code> so we can call it easily later.
At first, the <code>call/cc</code> expression returns the string <code>"original value"</code>,
and then a prefix <code>"prefix | "</code> is added and it’s saved in a variable called <code>value</code>.
When we print it with <code>(println value)</code>,
it shows the full string <code>"prefix | original value"</code>.
Then we call the continuation with <code>(continuation "new value")</code>.
This rolls back the state of the <code>value</code> definition,
with the output of the <code>call/cc</code> expression changed to <code>"new value"</code>.
The definition expression of <code>value</code> evaluates again from that point,
adding the prefix <code>"prefix | "</code> again.
Then we print <code>value</code> again, giving the new value <code>"prefix | new value"</code>.</p>
<p>To summarize what happened,
the continuation saved the state of the program,
and when we called it later, it rewound the program back to the saved state and made <code>call/cc</code> return a different value.</p>
<p>In other words, the continuation can pass values back in time.
One way to think about this is that <code>call/cc</code> both generates a time machine (continuation) and acts as a receiver for future information that get sent backwards in time.
That’s why we were seeing the strange behavior from before.</p>
<p>What is this function used for? Why does it exist?
As it turns out,
you can use it to implement control flow constructs that usual functional programming features can’t easily represent,
like loops, break statements, return statements, generators, and coroutines.
However, that is beyond the scope of this post,
so let’s keep trying to figure out what’s going on.</p>
<h2 id="how-the-code-works">How the code works</h2>
<p>Now that we understand <code>call/cc</code>,
we can return to the code and try to understand how it works.</p>
<pre data-lang="racket" class="language-racket "><code class="language-racket" data-lang="racket">(call&#x2F;cc (lambda ([not_em : (Not (EM A))]) : (EM A)
            (Right (lambda ([a : A])
                     (not_em (Left a))))))
</code></pre>
<h3 id="the-continuation">The continuation</h3>
<p>The <code>not_em</code> function is the continuation,
and it has type <code>(Not (EM A))</code>.
Recall that this means it is a function that takes an argument
of type <code>(EM A)</code> and returns a value of type <code>Nothing</code>,
which doesn’t actually exist.
Under the Curry-Howard isomorphism,
<code>not_em</code> can be interpreted as a proof that “\(A\) or not \(A\)” implies a contradiction.
Also, empty types like <code>Nothing</code> in Racket and the never type in Rust are commonly used for expressions with abnormal control flow that don’t evaluate to a value normally, such as <code>break</code> statements.
The <code>not_em</code> function is a continuation; it doesn’t actually return a value, so it makes sense that its return type can be <code>Nothing</code>.</p>
<h3 id="the-result">The result</h3>
<p>Initially (in the first timeline), the <code>call/cc</code> expression
evaluates to</p>
<pre data-lang="racket" class="language-racket "><code class="language-racket" data-lang="racket">(Right (lambda ([a : A])
         (not_em (Left a))))
</code></pre>
<p>The <code>Right</code> type constructor corresponds to the “false” part of the excluded middle,
which is why our oracle started out saying everything was false.
The type of this expression is <code>(EM A)</code>,
which is the same as <code>(Either A (Not A))</code>,
which we can expand further into <code>(Either A (-&gt; A Nothing))</code>.</p>
<p>So the expression</p>
<pre data-lang="racket" class="language-racket "><code class="language-racket" data-lang="racket">(lambda ([a : A])
  (not_em (Left a)))
</code></pre>
<p>passed to the <code>Right</code> constructor must have type <code>(-&gt; A Nothing)</code>.
The parameter does have type <code>A</code>,
and the body of the function calls a continuation,
which means the body has type <code>Nothing</code>.
So the type of <code>(-&gt; A Nothing)</code> makes sense.
Further, since <code>a</code> has type <code>A</code>,
it must be the case that <code>(Left a)</code> has type <code>(EM A)</code>.
And <code>not_em</code>, the continuation, has type <code>(-&gt; (EM A) Nothing)</code>,
so it also makes sense that the <code>not_em</code> call type checks.</p>
<p>Okay, that’s why it type checks.
What about the behavior?
Initially for a statement <code>A</code>,
the oracle always returned a <code>Right</code> value,
corresponding to a proof that <code>(Not A)</code>,
or <code>(-&gt; A Nothing)</code>,
a function that takes <code>A</code> and returns <code>Nothing</code>.
When we gave the function a value <code>a</code> of type <code>A</code>,
the state of the program got rolled back to the oracle,
and it returned <code>(Left a)</code> instead.</p>
<pre data-lang="racket" class="language-racket "><code class="language-racket" data-lang="racket">(Right (lambda ([a : A])
         (not_em (Left a))))
</code></pre>
<p>This is <em>exactly</em> what this code does.
It returns <code>Right</code> with a function that takes an argument <code>a</code>,
and calls the continuation with <code>(Left a)</code>,
rolling back the state of the program to when the oracle was called
and rerunning it with the new output.</p>
<h2 id="the-devil-of-the-excluded-middle">The Devil of the Excluded Middle</h2>
<p><a href="https://homepages.inf.ed.ac.uk/wadler/papers/dual/dual.pdf">Philip Wadler has a story</a> about the computational interpretation of the law of excluded middle:</p>
<blockquote>
<p>Once upon a time, the devil approached a man and made
an offer: “Either (a) I will give you one billion dollars, or (b)
I will grant you any wish if you pay me one billion dollars.
Of course, I get to choose whether I offer (a) or (b).”</p>
<p>The man was wary. Did he need to sign over his soul?
No, said the devil, all the man need do is accept the offer.</p>
<p>The man pondered. If he was offered (b) it was unlikely
that he would ever be able to buy the wish, but what was
the harm in having the opportunity available?</p>
<p>“I accept,” said the man at last. “Do I get (a) or (b)?”</p>
<p>The devil paused. “I choose (b).”</p>
<p>The man was disappointed but not surprised. That was
that, he thought. But the offer gnawed at him. Imagine
what he could do with his wish! Many years passed, and
the man began to accumulate money. To get the money he
sometimes did bad things, and dimly he realized that this
must be what the devil had in mind. Eventually he had his
billion dollars, and the devil appeared again.</p>
<p>“Here is a billion dollars,” said the man, handing over a
valise containing the money. “Grant me my wish!”</p>
<p>The devil took possession of the valise. Then he said,
“Oh, did I say (b) before? I’m so sorry. I meant (a). It is
my great pleasure to give you one billion dollars.”</p>
<p>And the devil handed back to the man the same valise
that the man had just handed to him.</p>
</blockquote>
<p>So our “truth oracle” reveals itself as a
computational manifestation of the devil’s bargain from this story.
In hindsight, it makes sense that the program that Curry-Howard-corresponds to the law of excluded middle has to behave like this.
It needs to actually return a concrete value, since it’s a computer program,
but it also can’t ever give the wrong answer, since that would give a value of the empty type and break the type system.
So instead it hides a time machine inside the value,
and rigs it to activate, as a fail-safe mechanism, whenever code tries to use it to do something that would disastrously break the programming language.</p>

  <hr/>
</main>
<p class="tags">
</p>
</div>

        <!-- 100% privacy-first analytics -->
        <script data-collect-dnt="true" async src="https://scripts.simpleanalyticscdn.com/latest.js"></script>
    </body>
</html>
